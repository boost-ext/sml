<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">

<meta name="author" content="Krzysztof Jusiak">
<link rel="canonical" href="http://boost-experimental.github.io/msm-lite/tutorial/index.html">
<title>Tutorial - Boost.MSM-lite</title>

<link href="../css/boostbook.css" rel="stylesheet">
<link href="../css/styles/github.css" rel="stylesheet">
<link rel="stylesheet" href="../css/codemirror.css">
<link rel="stylesheet" href="../css/highlight.css">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../images/boost.png"></td>
</tr></table>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../overview/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../user_guide/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<div class="chapter">


<div class="toc">
<dl class="toc">

    
        <dt><span class="section"><a href="#0-read-boostmsm-euml-documentation">0. Read Boost.MSM - eUML documentation</a></span></dt>
    

    
        <dt><span class="section"><a href="#1-create-events-and-states">1. Create events and states</a></span></dt>
    

    
        <dt><span class="section"><a href="#2-create-guards-and-actions">2. Create guards and actions</a></span></dt>
    

    
        <dt><span class="section"><a href="#3-create-a-transition-table">3. Create a transition table</a></span></dt>
    

    
        <dt><span class="section"><a href="#4-set-initial-states">4. Set initial states</a></span></dt>
    

    
        <dt><span class="section"><a href="#5-create-a-state-machine">5. Create a state machine</a></span></dt>
    

    
        <dt><span class="section"><a href="#6-process-events">6. Process events</a></span></dt>
    

    
        <dt><span class="section"><a href="#8-handle-errors">8. Handle errors</a></span></dt>
    

    
        <dt><span class="section"><a href="#9-test-it">9. Test it</a></span></dt>
    

    
        <dt><span class="section"><a href="#10-debug-it">10. Debug it</a></span></dt>
    

</dl>
</div>



<div class="section">
<p>All code examples include <code>boost/msm-lite.hpp</code> as well as declare a convienent msm namespace alias.</p>
<pre><code class="cpp">#include &lt;boost/msm-lite.hpp&gt;
namespace msm = boost::msm::lite;
</code></pre>

<h3 id="0-read-boostmsm-euml-documentation">0. Read Boost.MSM - eUML documentation</h3>
<ul>
<li><a href="http://www.boost.org/doc/libs/1_60_0/libs/msm/doc/HTML/ch02.html">Boost.MSM - UML Short Guide</a></li>
<li><a href="http://www.boost.org/doc/libs/1_60_0/libs/msm/doc/HTML/ch03s04.html">Boost.MSM - eUML Documentation</a></li>
</ul>
<h3 id="1-create-events-and-states">1. Create events and states</h3>
<p>State machine is composed of finite number of states and transitions which are triggered via events.</p>
<p>An Event is just a unique type, which will be processed by the state machine.</p>
<pre><code class="cpp">struct my_event { ... };
</code></pre>

<p>You can also create event instance in order to simplify transition table notation.</p>
<pre><code class="cpp">auto event = msm::event&lt;my_event&gt;;
</code></pre>

<p>If you happen to have a Clang/GCC compiler, you can create an Event on the fly.</p>
<pre><code class="cpp">using namespace msm;
auto event  = &quot;event&quot;_t;
</code></pre>

<p>However, such event will not store any data.</p>
<p>A State can have entry/exit behaviour executed whenever machine enters/leaves State and
represents current location of the state machine flow.</p>
<p>To create a state below snippet might be used.</p>
<pre><code class="cpp">msm::state&lt;class idle&gt; idle;
// or
auto idle = msm::state&lt;class idle&gt;{};
</code></pre>

<p>If you happen to have a Clang/GCC compiler, you can create a State on the fly.</p>
<pre><code class="cpp">using namespace msm;
auto state  = &quot;idle&quot;_s;
</code></pre>

<p>However, please notice that above solution is a non-standard extension for Clang/GCC.</p>
<p><code>msm-lite</code> states cannot have data as data is injected directly into guards/actions instead.</p>
<p>A state machine might be a State itself.</p>
<pre><code class="cpp">msm::state&lt;msm::sm&lt;state_machine&gt;&gt; composite;
</code></pre>

<p><code>msm-lite</code> supports <code>terminate</code> state, which stops events to be processed. It defined by <code>X</code>.</p>
<pre><code class="cpp">  &quot;state&quot;_s = X;
</code></pre>

<p>States are printable too.</p>
<pre><code class="cpp">assert(string(&quot;idle&quot;) == &quot;idle&quot;_s.c_str());
</code></pre>

<p><img alt="CPP(BTN)" src="../Run_Events_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/events.cpp" />
<img alt="CPP(BTN)" src="../Run_States_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/states.cpp" />
<img alt="CPP(BTN)" src="../Run_Composite_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/composite.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="2-create-guards-and-actions">2. Create guards and actions</h3>
<p>Guards and actions are callable objects which will be executed by the state machine in order to verify whether a transition, followed by an action should take place.</p>
<p>Guard MUST return boolean value.</p>
<pre><code class="cpp">auto guard1 = [] {
  return true;
};

auto guard2 = [](int, double) { // guard with dependencies
  return true;
};

auto guard3 = [](int, auto event, double) { // guard with an event and dependencies
  return true;
};

struct guard4 {
    bool operator()() const noexcept {
        return true;
    }
};
</code></pre>

<p>Action MUST not return.</p>
<pre><code class="cpp">auto action1 = [] { };
auto action2 = [](int, double) { }; // action with dependencies
auto action3 = [](int, auto event, double) { }; // action with an event and dependencies
struct action4 {
    void operator()() noexcept { }
};
</code></pre>

<p><img alt="CPP(BTN)" src="../Run_Actions_Guards_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/actions_guards.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="3-create-a-transition-table">3. Create a transition table</h3>
<p>When we have states and events handy we can finally create a transition table which represents
our transitions.</p>
<p><code>msm-lite</code> is using eUML-like DSL in order to be as close as possible to UML design.</p>
<ul>
<li>
<p>Transition Table DSL</p>
<ul>
<li>Postfix Notation</li>
</ul>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>state + event<e> [ guard ]</td>
<td>internal transition on event e when guard</td>
</tr>
<tr>
<td>src_state / [] {} = dst_state</td>
<td>anonymous transition with action</td>
</tr>
<tr>
<td>src_state + event<e> = dst_state</td>
<td>transition on event e without guard or action</td>
</tr>
<tr>
<td>src_state + event<e> [ guard ] / action = dst_state</td>
<td>transition from src_state to dst_state on event e with guard and action</td>
</tr>
<tr>
<td>src_state + event<e> [ guard &amp;&amp; (![]{return true;} &amp;&amp; guard2) ] / (action, action2, []{}) = dst_state</td>
<td>transition from src_state to dst_state on event e with guard and action</td>
</tr>
</tbody>
</table>
<ul>
<li>Prefix Notation</li>
</ul>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>state + event<e> [ guard ]</td>
<td>internal transition on event e when guard</td>
</tr>
<tr>
<td>dst_state &lt;= src_state / [] {}</td>
<td>anonymous transition with action</td>
</tr>
<tr>
<td>dst_state &lt;= src_state + event<e></td>
<td>transition on event e without guard or action</td>
</tr>
<tr>
<td>dst_state &lt;= src_state + event<e> [ guard ] / action</td>
<td>transition from src_state to dst_state on event e with guard and action</td>
</tr>
<tr>
<td>dst_state &lt;= src_state + event<e> [ guard &amp;&amp; (![]{return true;} &amp;&amp; guard2) ] / (action, action2, []{})</td>
<td>transition from src_state to dst_state on event e with guard and action</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Transition flow</p>
</li>
</ul>
<pre><code>src_state + event [ guard ] / action = dst_state
                                     ^
                                     |
                                     |
                                    1. src_state + on_exit
                                    2. dst_state + on_entry
</code></pre>

<p>To create a transition table <a href="../user_guide/index.html#make_transition_table-state-machine"><code>make_transition_table</code></a> is provided.</p>
<pre><code class="cpp">using namespace msm; // Postfix Notation

make_transition_table(
 *&quot;src_state&quot;_s + event&lt;my_event&gt; [ guard ] / action = &quot;dst_state&quot;_s
, &quot;dst_state&quot;_s + &quot;other_event&quot;_t = X
);
</code></pre>

<p>or</p>
<pre><code class="cpp">using namespace msm; // Prefix Notation

make_transition_table(
  &quot;dst_state&quot;_s &lt;= *&quot;src_state&quot;_s + event&lt;my_event&gt; [ guard ] / action
, X             &lt;= &quot;dst_state&quot;_s  + &quot;other_event&quot;_t
);
</code></pre>

<p><img alt="CPP(BTN)" src="../Run_Transition_Table_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/transitions.cpp" />
<img alt="CPP(BTN)" src="../Run_eUML_Emulation_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/euml_emulation.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="4-set-initial-states">4. Set initial states</h3>
<p>Initial state tells the state machine where to start. It can be set by prefixing a State with <code>*</code>.</p>
<pre><code class="cpp">using namespace msm;
make_transition_table(
 *&quot;src_state&quot;_s + event&lt;my_event&gt; [ guard ] / action = &quot;dst_state&quot;_s,
  &quot;dst_state&quot;_s + event&lt;game_over&gt; = X
);
</code></pre>

<p>Initial/Current state might be remembered by the State Machine so that whenever it will reentered
the last active state will reactivated. In order to enable history you just have
to replace <code>*</code> with postfixed <code>(H)</code> when declaring the initial state.</p>
<pre><code class="cpp">using namespace msm;
make_transition_table(
  &quot;src_state&quot;_s(H) + event&lt;my_event&gt; [ guard ] / action = &quot;dst_state&quot;_s,
  &quot;dst_state&quot;_s    + event&lt;game_over&gt;                   = X
);
</code></pre>

<p>You can have more than one initial state. All initial states will be executed in pseudo-parallel way
and are called orthogonal regions.</p>
<pre><code class="cpp">using namespace msm;
make_transition_table(
 *&quot;region_1&quot;_s   + event&lt;my_event1&gt; [ guard ] / action = &quot;dst_state1&quot;_s,
  &quot;dst_state1&quot;_s + event&lt;game_over&gt; = X,

 *&quot;region_2&quot;_s   + event&lt;my_event2&gt; [ guard ] / action = &quot;dst_state2&quot;_s,
  &quot;dst_state2&quot;_s + event&lt;game_over&gt; = X
);
</code></pre>

<p><img alt="CPP(BTN)" src="../Run_Orthogonal_Regions_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/orthogonal_regions.cpp" />
<img alt="CPP(BTN)" src="../Run_History_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/history.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="5-create-a-state-machine">5. Create a state machine</h3>
<p>State machine is an abstraction for transition table holding current states and processing events.
To create a state machine, we have to configure our transition table.</p>
<pre><code class="cpp">class example {
public:
  auto configure() noexcept {
    using namespace msm;
    return make_transition_table(
     *&quot;src_state&quot;_s + event&lt;my_event&gt; [ guard ] / action = &quot;dst_state&quot;_s,
      &quot;dst_state&quot;_s + event&lt;game_over&gt; = X
    );
  }
};
</code></pre>

<p>Having transition table configured we can create a state machine.</p>
<pre><code class="cpp">msm::sm&lt;example&gt; sm;
</code></pre>

<p>State machine constructor provides required dependencies for actions and guards.</p>
<pre><code class="cpp">                            /---- event (injected from process_event)
                            |
auto guard = [](double d, auto event) { return true; }
                   |
                   \-------\
                           |
auto action = [](int i){}  |
                 |         |
                 |         |
                 \-\   /---/
                   |   |
msm::sm&lt;exmple&gt; s{42, 87.0};

msm::sm&lt;exmple&gt; s{87.0, 42}; // order in which parameters have to passed is not specificied
</code></pre>

<p>Passing and maintaining a lot of dependencies might be tedious and requires huge amount of boilerplate code.
In order to avoid it, Dependency Injection Library might be used to automate this process.
For example, we can use <a href="https://github.com/boost-experimental/di">Experimental Boost.DI</a>.</p>
<pre><code class="cpp">auto injector = di::make_injector(
    di::bind&lt;&gt;.to(42)
  , di::bind&lt;interface&gt;.to&lt;implementation&gt;()
);

auto sm = injector.create&lt;sm&lt;example&gt;&gt;();
assert(sm.process_event(e1{}));
</code></pre>

<p><img alt="CPP(BTN)" src="../Run_Hello_World_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/hello_world.cpp" />
<img alt="CPP(BTN)" src="../Run_Dependency_Injection_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/dependency_injection.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="6-process-events">6. Process events</h3>
<p>State machine is a simple creature. Its main purpose is to process events.
In order to do it, <code>process_event</code> method might be used.</p>
<pre><code class="cpp">msm::sm&lt;example&gt; sm;

assert(sm.process_event(my_event{})); // returns true when handled
assert(!sm.process_event(int{})); // not handled by the state machine
</code></pre>

<p>Process event might be also triggered on transition table.</p>
<pre><code>using namespace msm;
return make_transition_table(
 *&quot;s1&quot;_s + event&lt;my_event&gt; / process_event(other_event{}) = &quot;s2&quot;_s,
  &quot;s2&quot;_s + event&lt;other_event&gt; = X
);
</code></pre>

<p><code>msm-lite</code> also provides a way to dispatch dynamically created events into the state machine.</p>
<pre><code class="cpp">struct game_over {
  static constexpr auto id = SDL_QUIT;
  // explicit game_over(const SDL_Event&amp;) noexcept; // optional, when defined runtime event will be passed
};

auto dispatch_event = msm::make_dispatch_table&lt;SDL_Event, SDL_FIRSTEVENT, SDL_LASTEVENT&gt;(sm);
SDL_Event event{SDL_QUIT};
assert(dispatch_event(event, event.type)); // will call sm.process(game_over{});
</code></pre>

<p><img alt="CPP(BTN)" src="../Run_Hello_World_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/hello_world.cpp" />
<img alt="CPP(BTN)" src="../Run_Dispatch_Table_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/dispatch_table.cpp" />
<img alt="CPP(BTN)" src="../Run_SDL2_Integration_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/sdl2.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="8-handle-errors">8. Handle errors</h3>
<p>Different errors may occur when processing events. Firstly, event might not be handled (transition has not happened).
In such scenario <code>process_event</code> returns false and <code>unexpected_event</code> is fired.</p>
<pre><code class="cpp">make_transition_table(
 *&quot;src_state&quot;_s + event&lt;my_event&gt; [ guard ] / action = &quot;dst_state&quot;_s
, &quot;src_state&quot;_s + unexpected_event&lt;some_event&gt; = X
);
</code></pre>

<p>Usually, it is handy to create additional orthogonal region in order to handle unexpected scenarios.
This way State in which unexpected event occurred does not matter.</p>
<pre><code class="cpp">make_transition_table(
 *&quot;idle&quot;_s + event&lt;my_event&gt; [ guard ] / action = &quot;s1&quot;_s
, &quot;s1&quot;_s + event&lt;other_event&gt; [ guard ] / action = &quot;s2&quot;_s
, &quot;s2&quot;_s + event&lt;yet_another_event&gt; [ guard ] / action = X

,*&quot;error_handler&quot;_s + unexpected_event&lt;some_event&gt; = X
);
</code></pre>

<p>We can always check whether a State Machine is in terminate state by.</p>
<pre><code class="cpp">assert(sm.is(msm::X)); // doesn't matter how many regions there are
</code></pre>

<p>However, unexpected events do not cover all problems we can get into. Sometimes, exception might be thrown (when they are enabled).
Boost.MSM-lite handles those the same way as unexpected events via <code>exception</code> event.
Please notice that for performance reasons when exceptions are enabled (__cpp_exceptions defined) <code>noexcept</code> should be added
onto <code>configure</code> in order to disable handling exceptions when they can not be thrown.</p>
<pre><code class="cpp">class example {
public:
  auto configure() noexcept; // no exceptions handling, terminate will be called when throw will happen
}
</code></pre>

<pre><code class="cpp">class example {
public:
  auto configure(); // okay, guards/actions may throw now
}
</code></pre>

<pre><code class="cpp">make_transition_table(
 *&quot;idle&quot;_s + event&lt;event&gt; / [] { throw std::runtime_error{&quot;error&quot;}; }

,*&quot;error_handler&quot;_s + exception&lt;std::runtime_error&gt; = X
, &quot;error_handler&quot;_s + exception&lt;std::logic_error&gt; = X
, &quot;error_handler&quot;_s + exception&lt;&gt; / [] { cleanup...; } = X // any exception
);
</code></pre>

<p><img alt="CPP(BTN)" src="../Run_Error_Handling_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/error_handling.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="9-test-it">9. Test it</h3>
<p>Sometimes it's useful to verify whether a state machine is in a specific states, for example, if
we are in a terminate state or not. We can do it with <code>msm-lite</code> using <code>is</code> or <code>visit_current_states</code>
functionality.</p>
<pre><code class="cpp">msm::sm&lt;example&gt; sm;
assert(sm.process_event(my_event{}));
assert(sm.is(X)); // is(X, s1, ...) when you have orthogonal regions

//or

sm.visit_current_states([](auto state) { std::cout &lt;&lt; state.c_str() &lt;&lt; std::endl; });
</code></pre>

<p>On top of that, <code>msm-lite</code> provides testing facilities to check state machine as a whole.
<code>set_current_states</code> method is available from <code>testing::sm</code> in order to set state machine
in a requested state.</p>
<pre><code class="cpp">testing::sm&lt;example&gt; sm{fake_data...};
sm.set_current_states(&quot;s3&quot;_s); // set_current_states(&quot;s3&quot;_s, &quot;s1&quot;_s, ...) for orthogonal regions
assert(sm.process_event(event{}));
assert(sm.is(X));
</code></pre>

<p><img alt="CPP(BTN)" src="../Run_Testing_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/testing.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="10-debug-it">10. Debug it</h3>
<p><code>msm-lite</code> provides logging capabilities in order to inspect state machine flow.
To enable logging you have to define <code>BOOST_MSM_LITE_LOG</code>.</p>
<pre><code class="cpp">template &lt;class SM, class TEvent&gt;
void log_process_event(const TEvent&amp;) {
  printf(&quot;[%s][process_event] %s\n&quot;, typeid(SM).name(), typeid(TEvent).name());
}

template &lt;class SM, class TAction, class TEvent&gt;
void log_guard(const TAction&amp;, const TEvent&amp;, bool result) {
  printf(&quot;[%s][guard] %s %s %s\n&quot;, typeid(SM).name(), typeid(TAction).name(), typeid(TEvent).name(),
         (result ? &quot;[OK]&quot; : &quot;[Reject]&quot;));
}

template &lt;class SM, class TAction, class TEvent&gt;
void log_action(const TAction&amp;, const TEvent&amp;) {
  printf(&quot;[%s][action] %s %s\n&quot;, typeid(SM).name(), typeid(TAction).name(), typeid(TEvent).name());
}

template &lt;class SM, class TSrcState, class TDstState&gt;
void log_state_change(const TSrcState&amp; src, const TDstState&amp; dst) {
  printf(&quot;[%s][transition] %s -&gt; %s\n&quot;, typeid(SM).name(), src.c_str(), dst.c_str());
}

#define BOOST_MSM_LITE_LOG(T, SM, ...) log_##T&lt;SM&gt;(__VA_ARGS__)
#include &lt;boost/msm-lite.hpp&gt;
</code></pre>

<p><img alt="CPP(BTN)" src="../Run_Logging_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/logging.cpp" />
<img alt="CPP(BTN)" src="../Run_Plant_UML_Example|https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/plant_uml.cpp" /></p>
<p>&nbsp;</p>
<hr />
</div>

<script src="../js/jquery-2.1.1.min.js"></script>
<script src="../js/highlight.pack.js"></script>
<script src="../js/codemirror/codemirror.js"></script>
<script src="../js/codemirror/clike.js"></script>
<script src="../js/codemirror/active-line.js"></script>

<script src="../js/cpp.js"></script>
<script src="../js/gitter.js"></script>
<script src="../js/utility.js"></script>

<script>
hljs.configure({languages:['cpp']});
hljs.initHighlightingOnLoad();
</script>

<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &copy; 2016
      <p>Distributed under the Boost Software License, Version 1.0.
      (See accompanying file <code class="filename">LICENSE_1_0.txt</code> or copy at
      <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>

</div>
<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<select onChange="window.location.href=this.value" style="position: absolute; top: 20px; right: 30px; z-index: 10;">
  <option value="https://boost-experimental.github.io/di/boost">Theme: Boost</option>
  <option value="https://boost-experimental.github.io/di">Theme: Boost-Experimental</option>
</select>
</body>
</html>