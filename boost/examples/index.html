<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">

<meta name="author" content="Kris Jusiak">
<link rel="canonical" href="http://boost-experimental.github.io/sml/examples/index.html">
<title>Examples - Boost.SML</title>

<link href="../css/boostbook.css" rel="stylesheet">
<link href="../css/github.css" rel="stylesheet">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<div width="100%">
<a href="http://www.boost.org/"><img alt="Boost C++ Libraries" width="277" height="86" src="../images/boost.png"></a>
</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../user_guide/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../faq/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<div class="chapter">


<div class="toc">
<dl class="toc">

    
        <dt><span class="section"><a href="#hello-world">Hello World</a></span></dt>
    

    
        <dt><span class="section"><a href="#events">Events</a></span></dt>
    

    
        <dt><span class="section"><a href="#states">States</a></span></dt>
    

    
        <dt><span class="section"><a href="#actions-guards">Actions Guards</a></span></dt>
    

    
        <dt><span class="section"><a href="#transitions">Transitions</a></span></dt>
    

    
        <dt><span class="section"><a href="#deferprocess">Defer/Process</a></span></dt>
    

    
        <dt><span class="section"><a href="#orthogonal-regions">Orthogonal Regions</a></span></dt>
    

    
        <dt><span class="section"><a href="#composite">Composite</a></span></dt>
    

    
        <dt><span class="section"><a href="#history">History</a></span></dt>
    

    
        <dt><span class="section"><a href="#error-handling">Error handling</a></span></dt>
    

    
        <dt><span class="section"><a href="#logging">Logging</a></span></dt>
    

    
        <dt><span class="section"><a href="#testing">Testing</a></span></dt>
    

    
        <dt><span class="section"><a href="#runtime-dispatcher">Runtime Dispatcher</a></span></dt>
    

    
        <dt><span class="section"><a href="#euml-emulation">eUML Emulation</a></span></dt>
    

    
        <dt><span class="section"><a href="#dependencies">Dependencies</a></span></dt>
    

    
        <dt><span class="section"><a href="#dependency-injection">Dependency Injection</a></span></dt>
    

    
        <dt><span class="section"><a href="#sdl2-integration">SDL2 Integration</a></span></dt>
    

    
        <dt><span class="section"><a href="#plant-uml-integration">Plant UML Integration</a></span></dt>
    

</dl>
</div>



<div class="section">
<ul>
<li><a href="#hello-world">Hello World</a></li>
<li><a href="#events">Events</a></li>
<li><a href="#states">States</a></li>
<li><a href="#actions-guards">Actions Guards</a></li>
<li><a href="#transitions">Transitions</a></li>
<li><a href="#deferprocess">Defer/Process</a></li>
<li><a href="#orthogonal-regions">Orthogonal Regions</a></li>
<li><a href="#composite">Composite</a></li>
<li><a href="#history">History</a></li>
<li><a href="#error-handling">Error handling</a></li>
<li><a href="#logging">Logging</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#runtime-dispatcher">Runtime Dispatcher</a></li>
<li><a href="#euml-emulation">eUML Emulation</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#dependency-injection">Dependency Injection</a></li>
<li><a href="#sdl2-integration">SDL2 Integration</a></li>
<li><a href="#plant-uml-integration">Plant UML Integration</a></li>
</ul>
<hr />
<h3 id="hello-world">Hello World</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;

namespace sml = boost::sml;

struct release {};
struct ack {};
struct fin {};
struct timeout {};

const auto is_ack_valid = [](const ack&amp;) { return true; };
const auto is_fin_valid = [](const fin&amp;) { return true; };

const auto send_fin = [] {};
const auto send_ack = [] {};

#if !defined(_MSC_VER)
struct hello_world {
  auto operator()() const {
    using namespace sml;
    return make_transition_table(
      *&quot;established&quot;_s + event&lt;release&gt; / send_fin = &quot;fin wait 1&quot;_s,
       &quot;fin wait 1&quot;_s + event&lt;ack&gt; [ is_ack_valid ] = &quot;fin wait 2&quot;_s,
       &quot;fin wait 2&quot;_s + event&lt;fin&gt; [ is_fin_valid ] / send_ack = &quot;timed wait&quot;_s,
       &quot;timed wait&quot;_s + event&lt;timeout&gt; / send_ack = X
    );
  }
};

int main() {
  using namespace sml;

  sm&lt;hello_world&gt; sm;
  static_assert(1 == sizeof(sm), &quot;sizeof(sm) != 1b&quot;);
  assert(sm.is(&quot;established&quot;_s));

  sm.process_event(release{});
  assert(sm.is(&quot;fin wait 1&quot;_s));

  sm.process_event(ack{});
  assert(sm.is(&quot;fin wait 2&quot;_s));

  sm.process_event(fin{});
  assert(sm.is(&quot;timed wait&quot;_s));

  sm.process_event(timeout{});
  assert(sm.is(X));  // released
}
#else
class established;
class fin_wait_1;
class fin_wait_2;
class timed_wait;

struct hello_world {
  auto operator()() const {
    using namespace sml;
    return make_transition_table(
      *state&lt;established&gt; + event&lt;release&gt; / send_fin = state&lt;fin_wait_1&gt;,
       state&lt;fin_wait_1&gt; + event&lt;ack&gt; [ is_ack_valid ] = state&lt;fin_wait_2&gt;,
       state&lt;fin_wait_2&gt; + event&lt;fin&gt; [ is_fin_valid ] / send_ack = state&lt;timed_wait&gt;,
       state&lt;timed_wait&gt; + event&lt;timeout&gt; / send_ack = X
    );
  }
};

int main() {
  using namespace sml;

  sm&lt;hello_world&gt; sm;
  assert(sm.is(state&lt;established&gt;));

  sm.process_event(release{});
  assert(sm.is(state&lt;fin_wait_1&gt;));

  sm.process_event(ack{});
  assert(sm.is(state&lt;fin_wait_2&gt;));

  sm.process_event(fin{});
  assert(sm.is(state&lt;timed_wait&gt;));

  sm.process_event(timeout{});
  assert(sm.is(X));  // released
}
#endif
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/hello_world.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/hello_world.cpp</a></li>
</ul>
<h3 id="events">Events</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;

namespace sml = boost::sml;

struct e1 {};
struct e2 {
  bool value = true;
};
auto event2 = sml::event&lt;e2&gt;;

struct events {
  auto operator()() const noexcept {
    using namespace sml;
    auto guard = [](const e2&amp; e) { return e.value; };

    return make_transition_table(
       *&quot;idle&quot;_s + event&lt;e1&gt; = &quot;s1&quot;_s
      , &quot;s1&quot;_s + event2 [guard] = &quot;s2&quot;_s
      , &quot;s2&quot;_s + &quot;e3&quot;_e = &quot;s3&quot;_s
      , &quot;s3&quot;_s + event&lt;int&gt; / [] (int i) { assert(42 == i); } = X
    );
  }
};

int main() {
  sml::sm&lt;events&gt; sm;
  using namespace sml;
  sm.process_event(e1{});
  sm.process_event(e2{});
  sm.process_event(&quot;e3&quot;_e);
  sm.process_event(42);
  assert(sm.is(X));
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/events.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/events.cpp</a></li>
</ul>
<h3 id="states">States</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;

namespace sml = boost::sml;

struct e1 {};
struct e2 {};
struct e3 {};

struct states {
  auto operator()() const noexcept {
    using namespace sml;
    const auto idle = state&lt;class idle&gt;;
    return make_transition_table(
       *idle + event&lt;e1&gt; = &quot;s1&quot;_s
      , &quot;s1&quot;_s + sml::on_entry&lt;_&gt; / [] { std::cout &lt;&lt; &quot;s1 on entry&quot; &lt;&lt; std::endl; }
      , &quot;s1&quot;_s + sml::on_exit&lt;_&gt; / [] { std::cout &lt;&lt; &quot;s1 on exit&quot; &lt;&lt; std::endl; }
      , &quot;s1&quot;_s + event&lt;e2&gt; = state&lt;class s2&gt;
      , state&lt;class s2&gt; + event&lt;e3&gt; = X
    );
  }
};

int main() {
  sml::sm&lt;states&gt; sm;
  sm.process_event(e1{});
  sm.process_event(e2{});
  sm.process_event(e3{});
  assert(sm.is(sml::X));
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/states.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/states.cpp</a></li>
</ul>
<h3 id="actions-guards">Actions Guards</h3>
<pre><code class="cpp">
#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

namespace sml = boost::sml;


struct e1 {};
struct e2 {};
struct e3 {};
struct e4 {};
struct e5 {};

auto guard1 = [] {
  std::cout &lt;&lt; &quot;guard1&quot; &lt;&lt; std::endl;
  return true;
};

auto guard2 = [](int i) {
  assert(42 == i);
  std::cout &lt;&lt; &quot;guard2&quot; &lt;&lt; std::endl;
  return false;
};

bool guard3(int i) {
  assert(42 == i);
  std::cout &lt;&lt; &quot;guard3&quot; &lt;&lt; std::endl;
  return true;
}

auto action1 = [](auto e) { std::cout &lt;&lt; &quot;action1: &quot; &lt;&lt; typeid(e).name() &lt;&lt; std::endl; };
struct action2 {
  void operator()(int i) {
    assert(42 == i);
    std::cout &lt;&lt; &quot;action2&quot; &lt;&lt; std::endl;
  }
};

struct actions_guards {
  auto operator()() noexcept {
    using namespace sml;
    return make_transition_table(
       *&quot;idle&quot;_s + event&lt;e1&gt; = &quot;s1&quot;_s
      , &quot;s1&quot;_s + event&lt;e2&gt; [ guard1 ] / action1 = &quot;s2&quot;_s
      , &quot;s2&quot;_s + event&lt;e3&gt; [ guard1 &amp;&amp; ![] { return false;} ] / (action1, action2{}) = &quot;s3&quot;_s
      , &quot;s3&quot;_s + event&lt;e4&gt; [ !guard1 || guard2 ] / (action1, [] { std::cout &lt;&lt; &quot;action3&quot; &lt;&lt; std::endl; }) = &quot;s4&quot;_s
      , &quot;s3&quot;_s + event&lt;e4&gt; [ guard1 ] / ([] { std::cout &lt;&lt; &quot;action4&quot; &lt;&lt; std::endl; }, [this] { action4(); }) = &quot;s5&quot;_s
      , &quot;s5&quot;_s + event&lt;e5&gt; [ call(guard3) || guard2 ] / call(this, &amp;actions_guards::action5) = X
    );
  }

  void action4() const { std::cout &lt;&lt; &quot;action4&quot; &lt;&lt; std::endl; }

  void action5(int i, const e5&amp;) {
    assert(42 == i);
    std::cout &lt;&lt; &quot;action5&quot; &lt;&lt; std::endl;
  }
};

int main() {
  sml::sm&lt;actions_guards&gt; sm{42};
  sm.process_event(e1{});
  sm.process_event(e2{});
  sm.process_event(e3{});
  sm.process_event(e4{});
  sm.process_event(e5{});
  assert(sm.is(sml::X));
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/actions_guards.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/actions_guards.cpp</a></li>
</ul>
<h3 id="transitions">Transitions</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;

namespace sml = boost::sml;

struct e1 {};
struct e2 {};
struct e3 {};

struct transitions {
  auto operator()() const noexcept {
    using namespace sml;
    return make_transition_table(
       *&quot;idle&quot;_s                  / [] { std::cout &lt;&lt; &quot;anonymous transition&quot; &lt;&lt; std::endl; } = &quot;s1&quot;_s
      , &quot;s1&quot;_s + event&lt;e1&gt;        / [] { std::cout &lt;&lt; &quot;internal transition&quot; &lt;&lt; std::endl; }
      , &quot;s1&quot;_s + event&lt;e2&gt;        / [] { std::cout &lt;&lt; &quot;self transition&quot; &lt;&lt; std::endl; } = &quot;s1&quot;_s
      , &quot;s1&quot;_s + sml::on_entry&lt;_&gt; / [] { std::cout &lt;&lt; &quot;s1 entry&quot; &lt;&lt; std::endl; }
      , &quot;s1&quot;_s + sml::on_exit&lt;_&gt;  / [] { std::cout &lt;&lt; &quot;s1 exit&quot; &lt;&lt; std::endl; }
      , &quot;s1&quot;_s + event&lt;e3&gt;        / [] { std::cout &lt;&lt; &quot;external transition&quot; &lt;&lt; std::endl; } = X
    );
  }
};

int main() {
  sml::sm&lt;transitions&gt; sm;
  sm.process_event(e1{});
  sm.process_event(e2{});
  sm.process_event(e3{});
  assert(sm.is(sml::X));
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/transitions.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/transitions.cpp</a></li>
</ul>
<h3 id="deferprocess">Defer/Process</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &lt;queue&gt;

namespace sml = boost::sml;

struct e1 {};
struct e2 {};
struct e3 {};
struct e4 {};

struct defer_and_process {
  auto operator()() const noexcept {
    using namespace sml;
    return make_transition_table(
       *&quot;idle&quot;_s + event&lt;e1&gt; / defer
      , &quot;idle&quot;_s + event&lt;e2&gt; = &quot;s1&quot;_s
      , &quot;s1&quot;_s   + event&lt;e1&gt; = &quot;s2&quot;_s
      , &quot;s2&quot;_s   + event&lt;e3&gt; / process(e4{})
      , &quot;s2&quot;_s   + event&lt;e4&gt; = X
    );
  }
};

int main() {
  using namespace sml;
  sm&lt;defer_and_process, sml::defer_queue&lt;std::queue&gt;&gt; sm;  /// defer_queue policy to enable deferred events using std::queue
  assert(sm.is(&quot;idle&quot;_s));

  sm.process_event(e1{});
  assert(sm.is(&quot;idle&quot;_s));

  sm.process_event(e2{});  /// triggers idle -&gt; s1 and s1 -&gt; s2 (via deferred e1)
  assert(sm.is(&quot;s2&quot;_s));

  sm.process_event(e3{});  /// triggers s2.process(e4) -&gt; X (via processed e4)
  assert(sm.is(sml::X));
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/defer_and_process.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/defer_and_process.cpp</a></li>
</ul>
<h3 id="orthogonal-regions">Orthogonal Regions</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;

namespace sml = boost::sml;

struct e1 {};
struct e2 {};
struct e3 {};

struct orthogonal_regions {
  auto operator()() const noexcept {
    using namespace sml;
    return make_transition_table(
     *&quot;idle&quot;_s + event&lt;e1&gt; = &quot;s1&quot;_s
    , &quot;s1&quot;_s + event&lt;e2&gt; = X

    ,*&quot;idle2&quot;_s + event&lt;e2&gt; = &quot;s2&quot;_s
    , &quot;s2&quot;_s + event&lt;e3&gt; = X
    );
  }
};

int main() {
  sml::sm&lt;orthogonal_regions&gt; sm;
  using namespace sml;
  assert(sm.is(&quot;idle&quot;_s, &quot;idle2&quot;_s));
  sm.process_event(e1{});
  assert(sm.is(&quot;s1&quot;_s, &quot;idle2&quot;_s));
  sm.process_event(e2{});
  assert(sm.is(X, &quot;s2&quot;_s));
  sm.process_event(e3{});
  assert(sm.is(X, X));
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/orthogonal_regions.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/orthogonal_regions.cpp</a></li>
</ul>
<h3 id="composite">Composite</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;

namespace sml = boost::sml;

struct e1 {};
struct e2 {};
struct e3 {};
struct e4 {};
struct e5 {};

struct sub {
  auto operator()() const noexcept {
    using namespace sml;
      return make_transition_table(
       *&quot;idle&quot;_s + event&lt;e3&gt; / [] { std::cout &lt;&lt; &quot;in sub sm&quot; &lt;&lt; std::endl; } = &quot;s1&quot;_s
      , &quot;s1&quot;_s + event&lt;e4&gt; / [] { std::cout &lt;&lt; &quot;finish sub sm&quot; &lt;&lt; std::endl; } = X
      );
  }
};

struct composite {
  auto operator()() const noexcept {
    using namespace sml;
    return make_transition_table(
     *&quot;idle&quot;_s + event&lt;e1&gt; = &quot;s1&quot;_s
    , &quot;s1&quot;_s + event&lt;e2&gt; / [] { std::cout &lt;&lt; &quot;enter sub sm&quot; &lt;&lt; std::endl; } = state&lt;sub&gt;
    , state&lt;sub&gt; + event&lt;e5&gt; / [] { std::cout &lt;&lt; &quot;exit sub sm&quot; &lt;&lt; std::endl; } = X
    );
  }
};

int main() {
  sml::sm&lt;composite&gt; sm;

  using namespace sml;
  assert(sm.is(&quot;idle&quot;_s));
  assert(sm.is&lt;sub&gt;(&quot;idle&quot;_s));

  sm.process_event(e1{});
  assert(sm.is(&quot;s1&quot;_s));
  assert(sm.is&lt;sub&gt;(&quot;idle&quot;_s));

  sm.process_event(e2{});  // enter sub sm
  assert(sm.is(state&lt;sub&gt;));
  assert(sm.is&lt;sub&gt;(&quot;idle&quot;_s));

  sm.process_event(e3{});  // in sub sm
  assert(sm.is(state&lt;sub&gt;));
  assert(sm.is&lt;sub&gt;(&quot;s1&quot;_s));

  sm.process_event(e4{});  // finish sub sm
  assert(sm.is(state&lt;sub&gt;));
  assert(sm.is&lt;sub&gt;(X));

  sm.process_event(e5{});  // exit sub sm
  assert(sm.is(X));
  assert(sm.is&lt;sub&gt;(X));
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/composite.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/composite.cpp</a></li>
</ul>
<h3 id="history">History</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;

namespace sml = boost::sml;

struct sub {
  auto operator()() const noexcept {
    using namespace sml;
      return make_transition_table(
        &quot;s1&quot;_s &lt;= &quot;idle&quot;_s(H) + &quot;e1&quot;_e / [] { std::cout &lt;&lt; &quot;in sub&quot; &lt;&lt; std::endl; }
      , X      &lt;= &quot;s1&quot;_s      + &quot;e2&quot;_e / [] { std::cout &lt;&lt; &quot;in sub again&quot; &lt;&lt; std::endl; }
      );
  }
};

struct history {
  auto operator()() const noexcept {
    using namespace sml;
    return make_transition_table(
      state&lt;sub&gt; &lt;= *&quot;idle&quot;_s  + &quot;e1&quot;_e / [] { std::cout &lt;&lt; &quot;enter sub&quot; &lt;&lt; std::endl; }
    , &quot;s1&quot;_s     &lt;= state&lt;sub&gt; + &quot;e3&quot;_e / [] { std::cout &lt;&lt; &quot;exit sub&quot; &lt;&lt; std::endl; }
    , state&lt;sub&gt; &lt;= &quot;s1&quot;_s     + &quot;e4&quot;_e / [] { std::cout &lt;&lt; &quot;enter sub again&quot; &lt;&lt; std::endl; }
    );
  }
};

int main() {
  sml::sm&lt;history&gt; sm;
  using namespace sml;
  sm.process_event(&quot;e1&quot;_e);
  sm.process_event(&quot;e1&quot;_e);  // enter sub
  sm.process_event(&quot;e3&quot;_e);  // exit sub
  sm.process_event(&quot;e4&quot;_e);  // enter sub
  sm.process_event(&quot;e2&quot;_e);  // in sub again (history)
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/history.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/history.cpp</a></li>
</ul>
<h3 id="error-handling">Error handling</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

namespace sml = boost::sml;

struct some_event {};

struct error_handling {
  auto operator()() const {
    using namespace sml;
    return make_transition_table(
        *(&quot;idle&quot;_s) + &quot;event1&quot;_e / [] { throw std::runtime_error{&quot;error&quot;}; }
      ,   &quot;idle&quot;_s  + &quot;event2&quot;_e / [] { throw 0; }

      , *(&quot;exceptions handling&quot;_s) + exception&lt;std::runtime_error&gt; / [] { std::cout &lt;&lt; &quot;exception caught&quot; &lt;&lt; std::endl; }
      ,   &quot;exceptions handling&quot;_s  + exception&lt;_&gt; / [] { std::cout &lt;&lt; &quot;generic exception caught&quot; &lt;&lt; std::endl; } = X

      , *(&quot;unexpected events handling&quot;_s) + unexpected_event&lt;some_event&gt; / [] { std::cout &lt;&lt; &quot;unexpected event 'some_event'&quot; &lt;&lt; std::endl; }
      ,   &quot;unexpected events handling&quot;_s  + unexpected_event&lt;_&gt; / [] { std::cout &lt;&lt; &quot;generic unexpected event&quot; &lt;&lt; std::endl; } = X
    );
  }
};

int main() {
  using namespace sml;
  sm&lt;error_handling&gt; sm;

  sm.process_event(&quot;event1&quot;_e);  // throws runtime_error
  assert(sm.is(&quot;idle&quot;_s, &quot;exceptions handling&quot;_s, &quot;unexpected events handling&quot;_s));

  sm.process_event(&quot;event2&quot;_e);  // throws 0
  assert(sm.is(&quot;idle&quot;_s, X, &quot;unexpected events handling&quot;_s));

  sm.process_event(some_event{});  // unexpected event
  assert(sm.is(&quot;idle&quot;_s, X, &quot;unexpected events handling&quot;_s));

  sm.process_event(int{});  // unexpected any event
  assert(sm.is(&quot;idle&quot;_s, X, X));
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/error_handling.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/error_handling.cpp</a></li>
</ul>
<h3 id="logging">Logging</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

namespace sml = boost::sml;

struct my_logger {
  template &lt;class SM, class TEvent&gt;
  void log_process_event(const TEvent&amp;) {
    printf(&quot;[%s][process_event] %s\n&quot;, typeid(SM).name(), typeid(TEvent).name());
  }

  template &lt;class SM, class TGuard, class TEvent&gt;
  void log_guard(const TGuard&amp;, const TEvent&amp;, bool result) {
    printf(&quot;[%s][guard] %s %s %s\n&quot;, typeid(SM).name(), typeid(TGuard).name(), typeid(TEvent).name(),
           (result ? &quot;[OK]&quot; : &quot;[Reject]&quot;));
  }

  template &lt;class SM, class TAction, class TEvent&gt;
  void log_action(const TAction&amp;, const TEvent&amp;) {
    printf(&quot;[%s][action] %s %s\n&quot;, typeid(SM).name(), typeid(TAction).name(), typeid(TEvent).name());
  }

  template &lt;class SM, class TSrcState, class TDstState&gt;
  void log_state_change(const TSrcState&amp; src, const TDstState&amp; dst) {
    printf(&quot;[%s][transition] %s -&gt; %s\n&quot;, typeid(SM).name(), src.c_str(), dst.c_str());
  }
};

struct e1 {};
struct e2 {};

struct guard {
  bool operator()() const { return true; }
} guard;

struct action {
  void operator()() {}
} action;

struct logging {
  auto operator()() const noexcept {
    using namespace sml;
    return make_transition_table(
       *&quot;idle&quot;_s + event&lt;e1&gt; [ guard &amp;&amp; guard ] / action = &quot;s1&quot;_s
    );
  }
};

int main() {
  my_logger logger;
  sml::sm&lt;logging, sml::logger&lt;my_logger&gt;&gt; sm{logger};
  sm.process_event(e1{});
  sm.process_event(e2{});
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/logging.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/logging.cpp</a></li>
</ul>
<h3 id="testing">Testing</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &quot;boost/sml/testing/state_machine.hpp&quot;

namespace sml = boost::sml;

struct e1 {};
struct e2 {};
struct e3 {};

struct data {
  int value = 0;
};

struct testing {
  auto operator()() const noexcept {
    using namespace sml;

    const auto guard = [](data&amp; d) { return !d.value; };
    const auto action = [](data&amp; d) { d.value = 42; };

    return make_transition_table(
       *&quot;idle&quot;_s + event&lt;e1&gt; = &quot;s1&quot;_s
      , &quot;s1&quot;_s + event&lt;e2&gt; = &quot;s2&quot;_s
      , &quot;s2&quot;_s + event&lt;e3&gt; [guard] / action = X // transition under test
    );
  }
};

int main() {
  using namespace sml;
  data fake_data{0};
  sml::testing::sm&lt;::testing&gt; sm{fake_data};
  sm.set_current_states(&quot;s2&quot;_s);
  sm.process_event(e3{});
  assert(sm.is(X));
  assert(fake_data.value = 42);
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/testing.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/testing.cpp</a></li>
</ul>
<h3 id="runtime-dispatcher">Runtime Dispatcher</h3>
<pre><code class="cpp">#include &quot;boost/sml/utility/dispatch_table.hpp&quot;
#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;

namespace sml = boost::sml;

struct runtime_event {
  int id = 0;
};
struct event1 {
  static constexpr auto id = 1;
  event1(const runtime_event &amp;) {}
};
struct event2 {
  static constexpr auto id = 2;
};

struct dispatch_table {
  auto operator()() noexcept {
    using namespace sml;
    return make_transition_table(
       *&quot;idle&quot;_s + event&lt;event1&gt; = &quot;s1&quot;_s
      , &quot;s1&quot;_s + event&lt;event2&gt; = X
    );
  }
};

int main() {
  sml::sm&lt;dispatch_table&gt; sm;

  auto dispatch_event = sml::utility::make_dispatch_table&lt;runtime_event, 1 /*min*/, 5 /*max*/&gt;(sm);

  {
    runtime_event event{1};
    dispatch_event(event, event.id);
  }

  {
    runtime_event event{2};
    dispatch_event(event, event.id);
  }

  assert(sm.is(sml::X));
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/dispatch_table.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/dispatch_table.cpp</a></li>
</ul>
<h3 id="euml-emulation">eUML Emulation</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;

namespace sml = boost::sml;

struct e1 {};
struct e2 {};
struct e3 {};

auto event1 = sml::event&lt;e1&gt;;
auto event2 = sml::event&lt;e2&gt;;
auto event3 = sml::event&lt;e3&gt;;

auto idle = sml::state&lt;class idle&gt;;
auto s1 = sml::state&lt;class s1&gt;;
auto s2 = sml::state&lt;class s2&gt;;

class euml_emulation;

struct Guard {
  template &lt;class TEvent&gt;
  bool operator()(euml_emulation&amp;, const TEvent&amp;) const;
} guard;

struct Action {
  template &lt;class TEvent&gt;
  void operator()(euml_emulation&amp;, const TEvent&amp;);
} action;

class euml_emulation {
 public:
  auto operator()() const {
    using namespace sml;
    return make_transition_table(
      s1 &lt;= *idle + event1,
      s2 &lt;= s1    + event2 [ guard ],
      X  &lt;= s2    + event3 [ guard ] / action
    );
  }

  template &lt;class TEvent&gt;
  bool call_guard(const TEvent&amp;) {
    return true;
  }

  void call_action(const e3&amp;) {}
};

template &lt;class TEvent&gt;
bool Guard::operator()(euml_emulation&amp; sm, const TEvent&amp; event) const {
  return sm.call_guard(event);
}

template &lt;class TEvent&gt;
void Action::operator()(euml_emulation&amp; sm, const TEvent&amp; event) {
  sm.call_action(event);
}

int main() {
  euml_emulation euml;
  sml::sm&lt;euml_emulation&gt; sm{euml};
  assert(sm.is(idle));
  sm.process_event(e1{});
  assert(sm.is(s1));
  sm.process_event(e2{});
  assert(sm.is(s2));
  sm.process_event(e3{});
  assert(sm.is(sml::X));
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/euml_emulation.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/euml_emulation.cpp</a></li>
</ul>
<h3 id="dependencies">Dependencies</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &lt;queue&gt;

namespace sml = boost::sml;

struct e1 {
  int i = 0;
};
struct dependency {
  int i = 0;
};

struct dependencies {
  auto operator()() const noexcept {
    using namespace sml;

    const auto guard = [](dependency&amp; d) {  /// more dependencies might be passed
      return !d.i;
    };

    const auto action = [](dependency&amp; d,
                           const auto&amp; event) {  /// event is deduced, order is not important
      d.i = event.i + 42;
    };

    return make_transition_table(
       *&quot;idle&quot;_s + event&lt;e1&gt; [ guard ] / action = &quot;s1&quot;_s
      , &quot;s1&quot;_s   + event&lt;e1&gt; [ ([](const auto&amp; event, dependency&amp; d) { return d.i == event.i; }) ] = X
     );
  }
};

int main() {
  using namespace sml;
  dependency d;
  sm&lt;dependencies&gt; sm{d};  /// pass all dependencies (from guards, actions) via
                           /// constructor (order is not important)
  assert(sm.is(&quot;idle&quot;_s));

  sm.process_event(e1{0});
  assert(sm.is(&quot;s1&quot;_s));  /// action sets dependency.i to 42

  sm.process_event(e1{0});
  assert(sm.is(&quot;s1&quot;_s));  /// not satisfied, dependency.i(42) != event.i(0)

  sm.process_event(e1{42});
  assert(sm.is(X));  /// transition to X
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/dependencies.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/dependencies.cpp</a></li>
</ul>
<h3 id="dependency-injection">Dependency Injection</h3>
<pre><code class="cpp">#if __has_include(&lt;boost/di.hpp&gt;)
#include &lt;boost/sml.hpp&gt;
#include &lt;boost/di.hpp&gt;
#include &lt;cassert&gt;
#include &lt;typeinfo&gt;
#include &lt;iostream&gt;

namespace sml = boost::sml;

struct e1 {};
struct e2 {};
struct e3 {};

auto guard = [](int i, double d) {
  assert(42 == i);
  assert(87.0 == d);
  std::cout &lt;&lt; &quot;guard&quot; &lt;&lt; std::endl;
  return true;
};

auto action = [](int i, auto e) {
  assert(42 == i);
  std::cout &lt;&lt; &quot;action: &quot; &lt;&lt; typeid(e).name() &lt;&lt; std::endl;
};

struct example {
  auto operator()() const noexcept {
    using namespace sml;
    return make_transition_table(
       *&quot;idle&quot;_s + event&lt;e1&gt; = &quot;s1&quot;_s
      , &quot;s1&quot;_s + event&lt;e2&gt; [ guard ] / action = &quot;s2&quot;_s
      , &quot;s2&quot;_s + event&lt;e3&gt; / [] { std::cout &lt;&lt; &quot;in place action&quot; &lt;&lt; std::endl; } = X
    );
  }
};

namespace di = boost::di;

class controller {
 public:
  explicit controller(sml::sm&lt;example&gt;&amp; sm) : sm(sm) {}

  void start() {
    sm.process_event(e1{});
    sm.process_event(e2{});
    sm.process_event(e3{});
    assert(sm.is(sml::X));
  }

 private:
  sml::sm&lt;example&gt;&amp; sm;
};

int main() {
  auto injector = di::make_injector(di::bind&lt;&gt;.to(42), di::bind&lt;&gt;.to(87.0));
  injector.create&lt;controller&gt;().start();
}
#else
int main() {}
#endif
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/dependency_injection.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/dependency_injection.cpp</a></li>
</ul>
<h3 id="sdl2-integration">SDL2 Integration</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &quot;boost/sml/utility/dispatch_table.hpp&quot;

namespace sml = boost::sml;

#if __has_include(&lt;SDL2/SDL_events.h&gt;)
#include &lt;SDL2/SDL_events.h&gt;
#else
enum { SDLK_SPACE = ' ' };
enum SDL_EventType { SDL_FIRSTEVENT = 0, SDL_QUIT, SDL_KEYUP, SDL_MOUSEBUTTONUP, SDL_LASTEVENT };
struct SDL_KeyboardEvent {
  SDL_EventType type;
  struct {
    int sym;
  } keysym;
};
struct SDL_MouseButtonEvent {
  SDL_EventType type;
  int button;
};
struct SDL_QuitEvent {
  SDL_EventType type;
};
union SDL_Event {
  SDL_EventType type;
  SDL_KeyboardEvent key;
  SDL_MouseButtonEvent button;
  SDL_QuitEvent quit;
};
#endif

template &lt;SDL_EventType Id&gt;
struct sdl_event_impl {
  static constexpr auto id = Id;
  explicit sdl_event_impl(const SDL_Event&amp; data) noexcept : data(data) {}
  SDL_Event data;
};

template &lt;SDL_EventType Id&gt;
decltype(sml::event&lt;sdl_event_impl&lt;Id&gt;&gt;) sdl_event{};

auto is_key = [](auto key) { return [=](auto event) { return event.data.key.keysym.sym == key; }; };

struct sdl2 {
  auto operator()() const noexcept {
    using namespace sml;
    return make_transition_table(
      //------------------------------------------------------------------------------//
        &quot;wait_for_user_input&quot;_s &lt;= *&quot;idle&quot;_s
          / [] { std::cout &lt;&lt; &quot;initialization&quot; &lt;&lt; std::endl; }

      , &quot;key_pressed&quot;_s &lt;= &quot;wait_for_user_input&quot;_s + sdl_event&lt;SDL_KEYUP&gt; [ is_key(SDLK_SPACE) ]
          / [] { std::cout &lt;&lt; &quot;space pressed&quot; &lt;&lt; std::endl; }

      , X &lt;= &quot;key_pressed&quot;_s + sdl_event&lt;SDL_MOUSEBUTTONUP&gt;
          / [] { std::cout &lt;&lt; &quot;mouse button pressed&quot; &lt;&lt; std::endl; }
      //------------------------------------------------------------------------------//
      , X &lt;= *&quot;waiting_for_quit&quot;_s + sdl_event&lt;SDL_QUIT&gt;
          / [] { std::cout &lt;&lt; &quot;quit&quot; &lt;&lt; std::endl; }
      //------------------------------------------------------------------------------//
    );
  }
};

int main() {
  sml::sm&lt;sdl2&gt; sm;
  auto dispatch_event = sml::utility::make_dispatch_table&lt;SDL_Event, SDL_FIRSTEVENT, SDL_LASTEVENT&gt;(sm);

  SDL_Event event;

  // while (SDL_PollEvent(&amp;event)) {
  //   dispatch_event(event, event.type)
  // };

  {
    SDL_KeyboardEvent keyboard_event;
    keyboard_event.type = SDL_KEYUP;
    keyboard_event.keysym.sym = SDLK_SPACE;
    event.key = keyboard_event;
    dispatch_event(event, event.type);
  }

  {
    SDL_MouseButtonEvent mousebutton_event;
    mousebutton_event.type = SDL_MOUSEBUTTONUP;
    mousebutton_event.button = 1;
    event.button = mousebutton_event;
    dispatch_event(event, event.type);
  }

  {
    SDL_QuitEvent quit_event;
    quit_event.type = SDL_QUIT;
    event.quit = quit_event;
    dispatch_event(event, event.type);
  }

  assert(sm.is(sml::X, sml::X));
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/sdl2.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/sdl2.cpp</a></li>
</ul>
<h3 id="plant-uml-integration">Plant UML Integration</h3>
<pre><code class="cpp">#include &lt;boost/sml.hpp&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;

namespace sml = boost::sml;

struct e1 {};
struct e2 {};
struct e3 {};
struct e4 {};

struct guard {
  bool operator()() const { return true; }
} guard;

struct action {
  void operator()() {}
} action;

struct plant_uml {
  auto operator()() const noexcept {
    using namespace sml;
    return make_transition_table(
       *&quot;idle&quot;_s + event&lt;e1&gt; = &quot;s1&quot;_s
      , &quot;s1&quot;_s + event&lt;e2&gt; [ guard ] / action = &quot;s2&quot;_s
      , &quot;s2&quot;_s + event&lt;e3&gt; [ guard ] = &quot;s1&quot;_s
      , &quot;s2&quot;_s + event&lt;e4&gt; / action = X
    );
  }
};

template &lt;class T&gt;
void dump_transition() noexcept {
  auto src_state = std::string{sml::state&lt;typename T::src_state&gt;.c_str()};
  auto dst_state = std::string{sml::state&lt;typename T::dst_state&gt;.c_str()};
  if (dst_state == &quot;X&quot;) {
    dst_state = &quot;[*]&quot;;
  }

  if (T::initial) {
    std::cout &lt;&lt; &quot;[*] --&gt; &quot; &lt;&lt; src_state &lt;&lt; std::endl;
  }

  std::cout &lt;&lt; src_state &lt;&lt; &quot; --&gt; &quot; &lt;&lt; dst_state;

  const auto has_event = !sml::aux::is_same&lt;typename T::event, sml::detail::anonymous&gt;::value;
  const auto has_guard = !sml::aux::is_same&lt;typename T::guard, sml::detail::always&gt;::value;
  const auto has_action = !sml::aux::is_same&lt;typename T::action, sml::detail::none&gt;::value;

  if (has_event || has_guard || has_action) {
    std::cout &lt;&lt; &quot; :&quot;;
  }

  if (has_event) {
    std::cout &lt;&lt; &quot; &quot; &lt;&lt; typeid(typename T::event).name();
  }

  if (has_guard) {
    std::cout &lt;&lt; &quot; [&quot; &lt;&lt; typeid(typename T::guard).name() &lt;&lt; &quot;]&quot;;
  }

  if (has_action) {
    std::cout &lt;&lt; &quot; / &quot; &lt;&lt; typeid(typename T::action).name();
  }

  std::cout &lt;&lt; std::endl;
}

template &lt;template &lt;class...&gt; class T, class... Ts&gt;
void dump_transitions(const T&lt;Ts...&gt;&amp;) noexcept {
  int _[]{0, (dump_transition&lt;Ts&gt;(), 0)...};
  (void)_;
}

template &lt;class SM&gt;
void dump(const SM&amp;) noexcept {
  std::cout &lt;&lt; &quot;@startuml&quot; &lt;&lt; std::endl &lt;&lt; std::endl;
  dump_transitions(typename SM::transitions{});
  std::cout &lt;&lt; std::endl &lt;&lt; &quot;@enduml&quot; &lt;&lt; std::endl;
}

int main() {
  sml::sm&lt;plant_uml&gt; sm;
  dump(sm);
}
</code></pre>

<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/sml/master/example/plant_uml.cpp">https://raw.githubusercontent.com/boost-experimental/sml/master/example/plant_uml.cpp</a></li>
</ul>
</div>

<script src="../js/highlight.pack.js"></script>

<script>
hljs.configure({languages:['cpp']});
hljs.initHighlightingOnLoad();
</script>

<div class="copyright-footer">Copyright &copy; 2016
      <p>Distributed under the Boost Software License, Version 1.0.
      (See accompanying file <code class="filename">LICENSE_1_0.txt</code> or copy at
      <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>

</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../user_guide/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../faq/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<select onChange="window.location.href=this.value" style="position: absolute; top: 20px; right: 30px; z-index: 10;">
    <option value="https://boost-experimental.github.io/sml">Theme: Boost Experimental</option>
    <option value="https://boost-experimental.github.io/sml/boost" selected>Theme: Boost Classic</option>
</select>
</body>
</html>