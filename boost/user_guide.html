<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">



<title>User Guide - [Boost].SML</title>

<link href="./css/boostbook.css" rel="stylesheet">
<link href="./css/github.css" rel="stylesheet">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<div width="100%">
<a href="http://www.boost.org/"><img alt="Boost C++ Libraries" width="277" height="86" src="./images/boost.png"></a>
</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  ><img src="./images/prev.png" alt="Prev"></a><a accesskey="u" href=""><img src="./images/up.png" alt="Up"></a><a accesskey="h" href=""><img src="./images/home.png" alt="Home"></a><a accesskey="n"  ><img src="./images/next.png" alt="Next"></a>
</div>

<div class="chapter">


<div class="toc">
<dl class="toc">

    
        <dt><span class="section"><a href="index.html">Introduction</a></span></dt>
    

    
        <dt><span class="section"><a href="overview.html">Overview</a></span></dt>
    

    
        <dt><span class="section"><a href="benchmarks.html">Features/Benchmarks</a></span></dt>
    

    
        <dt><span class="section"><a href="tutorial.html">Tutorial/Workshop</a></span></dt>
    

    
        <dt><span class="section"><a href="uml_vs_sml.html">UML vs SML</a></span></dt>
    

    
        <dt><span class="section"><a href="user_guide.html">User Guide</a></span></dt>
    

    
        <dt><span class="section"><a href="examples.html">Examples</a></span></dt>
    

    
        <dt><span class="section"><a href="faq.html">FAQ</a></span></dt>
    

    
        <dt><span class="section"><a href="CHANGELOG.html">CHANGELOG</a></span></dt>
    

</dl>
</div>



<div class="section">
<h3 id="transitional-concept">transitional [concept]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/sml.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Requirements for transition.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class T&gt;
concept bool transitional() {
  return requires(T transition) {
    typename T::src_state;
    typename T::dst_state;
    typename T::event;
    typename T::deps;
    T::initial;
    T::history;
    { transition.execute() } -&gt; bool;
  }
};
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>transitional&lt;T&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>using namespace sml;

{
auto transition = ("idle"_s = X); // Postfix Notation
static_assert(transitional&lt;decltype(transition)&gt;::value);
}

{
auto transition = (X &lt;= "idle"_s); // Prefix Notation
static_assert(transitional&lt;decltype(transition)&gt;::value);
}
</code></pre>
<p><img alt="CPP(BTN)" src="Run_Transitional_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/errors/not_transitional.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="configurable-concept">configurable [concept]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/sml.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Requirements for the state machine.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class SM&gt;
concept bool configurable() {
  return requires(SM sm) {
    { sm.operator()() };
  }
};
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>configurable&lt;SM&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>class example {
  auto operator()() const noexcept {
    return make_transition_table();
  }
};

static_assert(configurable&lt;example&gt;::value);
</code></pre>
<p><img alt="CPP(BTN)" src="Run_Configurable_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/errors/not_configurable.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="callable-concept">callable [concept]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/sml.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Requirements for action and guards.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class TResult, class T&gt;
concept bool callable() {
  return requires(T object) {
    { object(...) } -&gt; TResult;
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>callable&lt;SM&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>auto guard = [] { return true; };
auto action = [] { };

static_assert(callable&lt;bool, decltype(guard)&gt;::value);
static_assert(callable&lt;void, decltype(action)&gt;::value);
</code></pre>
<p><img alt="CPP(BTN)" src="Run_Callable_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/errors/not_callable.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="dispatchable-concept">dispatchable [concept]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/sml.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Requirements for the dispatch table.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class TDynamicEvent, TEvent&gt;
concept bool dispatchable() {
  return requires(T) {
    typename TEvent::id;
    { TEvent(declval&lt;TDynamicEvent&gt;()) };
  }
};
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>dispatchable&lt;SM&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>struct runtime_event { };

struct event1 {
  static constexpr auto id = 1;
};

struct event2 {
  static constexpr auto id = 2;
  explicit event2(const runtime_event&amp;) {}
};

static_assert(dispatchable&lt;runtime_event, event1&gt;::value);
static_assert(dispatchable&lt;runtime_event, event2&gt;::value);
</code></pre>
<p><img alt="CPP(BTN)" src="Run_Dispatchable_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/errors/not_dispatchable.cpp" />
<img alt="CPP(BTN)" src="Run_SDL2_Integration_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/sdl2.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="state-core">state [core]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/sml.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Represents a state machine state.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template&lt;class TState&gt; // no requirements, TState may be a state machine
class state {
public:
  initial operator*() const noexcept; // no requirements

  template &lt;class T&gt; // no requirements
  auto operator&lt;=(const T &amp;) const noexcept;

  template &lt;class T&gt; // no requirements
  auto operator=(const T &amp;) const noexcept;

  template &lt;class T&gt; // no requirements
  auto operator+(const T &amp;) const noexcept;

  template &lt;class T&gt; requires callable&lt;bool, T&gt;
  auto operator[](const T) const noexcept;

  template &lt;class T&gt; requires callable&lt;void, T&gt;
  auto operator/(const T &amp;t) const noexcept;

  const char* c_str() noexcept;
};

template &lt;class T, T... Chrs&gt;
state&lt;unspecified&gt; operator""_s() noexcept;

// predefined states
state&lt;unspecified&gt; X;
</code></pre>
<p><strong><em>Requirements</em></strong></p>
<ul>
<li><a href="#callable-concept">callable</a></li>
</ul>
<p><strong><em>Semantics</em></strong></p>
<pre><code>state&lt;T&gt;{}
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>auto idle = state&lt;class idle&gt;;
auto idle = "idle"_s;

auto initial_state = *idle;
auto history_state = idle(H);
auto terminate_state = X;
</code></pre>
<p><img alt="CPP(BTN)" src="Run_States_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/states.cpp" />
<img alt="CPP(BTN)" src="Run_Composite_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/composite.cpp" />
<img alt="CPP(BTN)" src="Run_Orthogonal_Regions_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/orthogonal_regions.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="event-core">event [core]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/sml.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Represents a state machine event.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template&lt;TEvent&gt; // no requirements
class event {
public:
  template &lt;class T&gt; requires callable&lt;bool, T&gt;
  auto operator[](const T &amp;) const noexcept;

  template &lt;class T&gt; requires callable&lt;void, T&gt;
  auto operator/(const T &amp;t) const noexcept;
};

template&lt;class TEvent&gt;
event&lt;TEvent&gt; event{};

// predefined events
auto on_entry = event&lt;unspecified&gt;;
auto on_exit = event&lt;unspecified&gt;;

template&lt;class TEvent&gt; unexpected_event{};
template&lt;class T&gt; exception{};
</code></pre>
<p><strong><em>Requirements</em></strong></p>
<ul>
<li><a href="#callable-concept">callable</a></li>
</ul>
<p><strong><em>Semantics</em></strong></p>
<pre><code>event&lt;T&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>auto my_int_event = event&lt;int&gt;;
</code></pre>
<p><img alt="CPP(BTN)" src="Run_Events_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/action_guards.cpp" />
<img alt="CPP(BTN)" src="Run_Error_Handling_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/error_handling.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="make_transition_table-state-machine">make_transition_table [state machine]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/sml.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates a transition table.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class... Ts&gt; requires transitional&lt;Ts&gt;...
auto make_transition_table(Ts...) noexcept;
</code></pre>
<p><strong><em>Requirements</em></strong></p>
<ul>
<li><a href="#transitional-concept">transitional</a></li>
</ul>
<p><strong><em>Semantics</em></strong></p>
<pre><code>make_transition_table(transitions...);
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>auto transition_table_postfix_notation = make_transition_table(
  *"idle_s" + event&lt;int&gt; / [] {} = X
);

auto transition_table_prefix_notation = make_transition_table(
  X &lt;= *"idle_s" + event&lt;int&gt; / [] {}
);

class example {
public:
  auto operator()() const noexcept {
    return make_transition_table();
  }
};
</code></pre>
<p><img alt="CPP(BTN)" src="Run_Transition_Table_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/transitions.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="sm-state-machine">sm [state machine]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/sml.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates a State Machine.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template&lt;class T&gt; requires configurable&lt;T&gt;
class sm {
public:
  using states = unspecified; // unique list of states
  using events = unspecified; // unique list of events which can be handled by the State Machine
  using transitions = unspecified; // list of transitions

  sm(sm &amp;&amp;) = default;
  sm(const sm &amp;) = delete;
  sm &amp;operator=(const sm &amp;) = delete;

  template &lt;class... TDeps&gt; requires is_base_of&lt;TDeps, dependencies&gt;...
  sm(TDeps&amp;&amp;...) noexcept;

  template&lt;class TEvent&gt; // no requirements
  bool process_event(const TEvent&amp;)

  template &lt;class TVisitor&gt; requires callable&lt;void, TVisitor&gt;
  void visit_current_states(const TVisitor &amp;) const noexcept(noexcept(visitor(state{})));

  template &lt;class TState&gt;
  bool is(const state&lt;TState&gt; &amp;) const noexcept;

  template &lt;class... TStates&gt; requires sizeof...(TStates) == number_of_initial_states
  bool is(const state&lt;TStates&gt; &amp;...) const noexcept;
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TDeps...</code></td>
<td>is_base_of dependencies</td>
<td>constructor</td>
<td></td>
</tr>
<tr>
<td><code>process_event&lt;TEvent&gt;</code></td>
<td>-</td>
<td>process event <code>TEvent</code></td>
<td>returns true when handled, false otherwise</td>
</tr>
<tr>
<td><code>visit_current_states&lt;TVisitor&gt;</code></td>
<td><a href="#callable-concept">callable</a></td>
<td>visit current states</td>
<td>-</td>
</tr>
<tr>
<td><code>is&lt;TState&gt;</code></td>
<td>-</td>
<td>verify whether any of current states equals <code>TState</code></td>
<td>true when any current state matches <code>TState</code>, false otherwise</td>
</tr>
<tr>
<td><code>is&lt;TStates...&gt;</code></td>
<td>size of TStates... equals number of initial states</td>
<td>verify whether all current states match <code>TStates...</code></td>
<td>true when all states match <code>TState...</code>, false otherwise</td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>sml::sm&lt;T&gt;{...};
sm.process_event(TEvent{});
sm.visit_current_states([](auto state){});
sm.is(X);
sm.is(s1, s2);
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>struct my_event {};

class example {
public:
  auto operator()() const noexcept {
    using namespace sml;
    return make_transition_table(
      *"idle"_s + event&lt;my_event&gt; / [](int i) { std::cout &lt;&lt; i &lt;&lt; std::endl; } = X
    );
  }
};

sml::sm&lt;example&gt; sm{42};
assert(sm.is("idle"_s));
sm.process_event(int{}); // no handled, will call unexpected_event&lt;int&gt;
sm.process_event(my_event{}); // handled
assert(sm.is(X));

sm.visit_current_states([](auto state) { std::cout &lt;&lt; state.c_str() &lt;&lt; std::endl; });
</code></pre>
<p><img alt="CPP(BTN)" src="Run_Hello_World_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/hello_world.cpp" />
<img alt="CPP(BTN)" src="Run_Dependency_Injection_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/dependency_injection.cpp" />
<img alt="CPP(BTN)" src="Run_eUML_Emulation_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/euml_emulation.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="policies-state-machine">policies [state machine]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/sml.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Additional State Machine configurations.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>thread_safe&lt;Lockable&gt;
logger&lt;Loggable&gt;
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Lockable</code></td>
<td><code>lock/unlock</code></td>
<td>Lockable type</td>
<td><code>std::mutex</code>, <code>std::recursive_mutex</code></td>
</tr>
<tr>
<td><code>Loggable</code></td>
<td><code>log_process_event/log_state_change/log_action/log_guard</code></td>
<td>Loggable type</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong><em>Example</em></strong></p>
<pre><code>sml::sm&lt;example, sml::thread_safe&lt;std::recursive_mutex&gt;&gt; sm; // thread safe policy
sml::sm&lt;example, sml::logger&lt;my_logger&gt;&gt; sm; // logger policy
sml::sm&lt;example, sml::thread_safe&lt;std::recursive_mutex&gt;, sml::logger&lt;my_logger&gt;&gt; sm; // thread safe and logger policy
sml::sm&lt;example, sml::logger&lt;my_logger&gt;, sml::thread_safe&lt;std::recursive_mutex&gt;&gt; sm; // thread safe and logger policy
</code></pre>
<p><img alt="CPP(BTN)" src="Run_Logging_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/logging.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="testingsm-testing">testing::sm [testing]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/sml/testing/state_machine.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates a state machine with testing capabilities.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>namespace testing {
  template &lt;class T&gt;
  class sm : public sml::sm&lt;T&gt; {
   public:
    using sml::sm&lt;T&gt;::sm;

    template &lt;class... TStates&gt;
    void set_current_states(const detail::state&lt;TStates&gt; &amp;...) noexcept;
  };
}
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>set_current_states&lt;TStates...&gt;</code></td>
<td>-</td>
<td>set current states</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>sml::testing::sm&lt;T&gt;{...};
sm.set_current_states("s1"_s);
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>sml::testing::sm&lt;T&gt;{inject_fake_data...};
sm.set_current_states("s1"_s);
sm.process_event(TEvent{});
sm.is(X);
</code></pre>
<p><img alt="CPP(BTN)" src="Run_Testing_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/testing.cpp" /></p>
<p>&nbsp;</p>
<hr />
<h3 id="make_dispatch_table-utility">make_dispatch_table [utility]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/sml/utility/dispatch_table.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates a dispatch table to handle runtime events.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>namespace utility {
  template&lt;class TEvent, int EventRangeBegin, int EventRangeBegin, class SM&gt; requires dispatchable&lt;TEvent, typename SM::events&gt;
  callable&lt;bool, (TEvent, int)&gt; make_dispatch_table(sm&lt;SM&gt;&amp;) noexcept;
}
</code></pre>
<p><strong><em>Requirements</em></strong></p>
<ul>
<li><a href="#dispatchable-concept">dispatchable</a></li>
</ul>
<p><strong><em>Semantics</em></strong></p>
<pre><code>sml::utility::make_dispatch_table&lt;T, 0, 10&gt;(sm);
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>struct runtime_event {
  int id = 0;
};
struct event1 {
  static constexpr auto id = 1;
  event1(const runtime_event &amp;) {}
};

auto dispatch_event = sml::utility::make_dispatch_table&lt;runtime_event, 1 /*min*/, 5 /*max*/&gt;(sm);
dispatch_event(event, event.id);
</code></pre>
<p><img alt="CPP(BTN)" src="Run_Dispatch_Table_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/dispatch_table.cpp" />
<img alt="CPP(BTN)" src="Run_SDL2_Integration_Example|https://raw.githubusercontent.com/boost-experimental/sml/master/example/sdl2.cpp" /></p>
<p>&nbsp;</p>
<hr />
</div>

<script src="./js/highlight.pack.js"></script>

<script>
hljs.configure({languages:['cpp']});
hljs.initHighlightingOnLoad();
</script>
<script src="search/main.js"></script>

<div class="copyright-footer">
      <p>Distributed under the Boost Software License, Version 1.0.
      (See accompanying file <code class="filename">LICENSE_1_0.txt</code> or copy at
      <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>

</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  ><img src="./images/prev.png" alt="Prev"></a><a accesskey="u" href=""><img src="./images/up.png" alt="Up"></a><a accesskey="h" href=""><img src="./images/home.png" alt="Home"></a><a accesskey="n"  ><img src="./images/next.png" alt="Next"></a>
</div>

<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<select onChange="window.location.href=this.value" style="position: absolute; top: 20px; right: 30px; z-index: 10;">
    <option value="https://boost-experimental.github.io/sml">Theme: Boost Experimental</option>
    <option value="https://boost-experimental.github.io/sml/boost" selected>Theme: Boost Classic</option>
</select>
</body>
</html>